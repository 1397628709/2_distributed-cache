package consistenthash

import (
	"strconv"
	"testing"
)

// TestHashing 测试一致性哈希算法的基本功能和节点添加后的映射变化
func TestHashing(t *testing.T) {
	// 创建一个一致性哈希实例：每个真实节点有3个虚拟节点，自定义哈希函数
	// 自定义哈希函数：将字符串key转换为整数，再转为uint32（简化测试，便于计算）
	hash := New(3, func(key []byte) uint32 {
		i, _ := strconv.Atoi(string(key)) // 将key字符串转为整数（如"6"→6）
		return uint32(i)                  // 返回对应的uint32哈希值
	})

	// 向哈希环添加真实节点 "6", "4", "2"
	// 每个节点生成3个虚拟节点，虚拟节点的标识为"i+key"（i从0到2）
	// 根据自定义哈希函数，虚拟节点的哈希值如下：
	// - 节点"2"的虚拟节点："02"→2、"12"→12、"22"→22 → 哈希值 2,12,22
	// - 节点"4"的虚拟节点："04"→4、"14"→14、"24"→24 → 哈希值 4,14,24
	// - 节点"6"的虚拟节点："06"→6、"16"→16、"26"→26 → 哈希值 6,16,26
	// 排序后哈希环上的虚拟节点哈希值为：2,4,6,12,14,16,22,24,26
	hash.Add("6", "4", "2")

	// 测试用例：key对应的预期真实节点
	testCases := map[string]string{
		"2":  "2", // key="2"的哈希值是2 → 命中虚拟节点2 → 对应真实节点"2"
		"11": "2", // key="11"的哈希值是11 → 查找第一个≥11的虚拟节点12 → 对应真实节点"2"
		"23": "4", // key="23"的哈希值是23 → 查找第一个≥23的虚拟节点24 → 对应真实节点"4"
		"27": "2", // key="27"的哈希值是27 → 超出最大哈希值26，取第一个虚拟节点2 → 对应真实节点"2"
	}

	// 执行第一轮测试：验证每个key的映射是否符合预期
	for k, v := range testCases {
		if hash.Get(k) != v {
			t.Errorf("Asking for %s, should have yielded %s", k, v)
		}
	}

	// 向哈希环添加新的真实节点 "8"
	// 生成3个虚拟节点："08"→8、"18"→18、"28"→28 → 哈希值 8,18,28
	// 新增后哈希环排序：2,4,6,8,12,14,16,18,22,24,26,28
	hash.Add("8")

	// 更新测试用例：key="27"的映射应变化
	// key="27"的哈希值27 → 查找第一个≥27的虚拟节点28 → 对应真实节点"8"
	testCases["27"] = "8"

	// 执行第二轮测试：验证新增节点后映射是否符合预期
	for k, v := range testCases {
		if hash.Get(k) != v {
			t.Errorf("Asking for %s, should have yielded %s", k, v)
		}
	}

}
